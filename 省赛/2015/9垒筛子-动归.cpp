/*
递归解法可以的30% 
垒骰子

赌圣atm晚年迷恋上了垒骰子，就
是把骰子一个垒在另一个上边，不
能歪歪扭扭，要垒成方柱体。
经过长期观察，atm 发现了稳定骰
子的奥秘：有些数字的面贴着会互相排斥！
我们先来规范一下骰子：1 的对面
是 4，2 的对面是 5，3 的对面是 6。
假设有 m 组互斥现象，每组中的那
两个数字的面紧贴在一起，骰子就不
能稳定的垒起来。 
atm想计算一下有多少种不同的可能
的垒骰子方式。
两种垒骰子方式相同，当且仅当这两
种方式中对应高度的骰子的对应数字
的朝向都相同。
由于方案数可能过多，请输出模 10^9 + 7 
的结果。

不要小看了 atm 的骰子数量哦～

「输入格式」
第一行两个整数 n m
n表示骰子数目
接下来 m 行，每行两个整数 a b ，
表示 a 和 b 数字不能紧贴在一起。

「输出格式」
一行一个数，表示答案模 10^9 + 7 的结果。

「样例输入」
2 1
1 2

「样例输出」
544

「数据范围」
对于 30% 的数据：n <= 5
对于 60% 的数据：n <= 100
对于 100% 的数据：0 < n <= 10^9, m <= 36


资源约定：
峰值内存消耗 < 256M
CPU消耗  < 2000ms


请严格按要求输出，不要画蛇添足地打印
类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过
后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不
要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文
件中 #include <xxx>， 不能通过工程设
置而省略常用头文件。

提交时，注意选择所期望的编译器类型。

*/
#include<iostream>
#include<cstring>
using namespace std;
int op[7];
bool con[7][7]={0};

int main(){
	op[1]=4,op[4]=1;
	op[2]=5,op[5]=2;
	op[3]=6,op[6]=3;
	
	int n,m,x,y;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		cin>>x>>y;
		con[x][y]=true;
		con[y][x]=true;
	}
	int dp[n+1][7];
	memset(dp,0,sizeof(dp));
	for(int j=1;j<7;j++){
		dp[1][j]=4;
	}
	
	
	for(int i=2;i<n+1;i++){
		for(int j=1;j<7;j++){
			for(int k=1;k<7;k++){
				if(con[j][op[k]]){
					continue;
				}
				dp[i][j]+=dp[i-1][k];
			}
			dp[i][j]*=4;
		}
	}
	
	int ans=0;
	for(int j=1;j<7;j++){
		ans+=dp[n][j];
	}
	cout<<ans;
	return 0;
}

